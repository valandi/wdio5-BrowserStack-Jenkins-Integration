"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = void 0;
const utils = __importStar(require("@applitools/utils"));
const context_1 = require("./context");
const utils_1 = require("./utils");
const user_agent_1 = require("./user-agent");
const snippets = require('@applitools/snippets');
// eslint-disable-next-line
class Driver {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        if (options.driver instanceof Driver)
            return options.driver;
        this._spec = options.spec;
        this._utils = utils_1.makeSpecUtils(options.spec);
        if (options.logger)
            this._logger = options.logger;
        if (this._spec.isDriver(options.driver)) {
            this._target = (_c = (_b = (_a = this._spec).transformDriver) === null || _b === void 0 ? void 0 : _b.call(_a, options.driver)) !== null && _c !== void 0 ? _c : options.driver;
        }
        else {
            throw new TypeError('Driver constructor called with argument of unknown type!');
        }
        this._mainContext = new context_1.Context({
            spec: this._spec,
            context: (_f = (_e = (_d = this._spec).extractContext) === null || _e === void 0 ? void 0 : _e.call(_d, this._target)) !== null && _f !== void 0 ? _f : this._target,
            driver: this,
            logger: this._logger,
        });
        this._currentContext = this._mainContext;
    }
    get target() {
        return this._target;
    }
    get currentContext() {
        return this._currentContext;
    }
    get mainContext() {
        return this._mainContext;
    }
    get features() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.features;
    }
    get deviceName() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.deviceName;
    }
    get platformName() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.platformName;
    }
    get platformVersion() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.platformVersion;
    }
    get browserName() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.browserName;
    }
    get browserVersion() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.browserVersion;
    }
    get userAgent() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.userAgent;
    }
    get pixelRatio() {
        var _a;
        return (_a = this._driverInfo.pixelRatio) !== null && _a !== void 0 ? _a : 1;
    }
    get statusBarHeight() {
        var _a;
        return (_a = this._driverInfo.statusBarHeight) !== null && _a !== void 0 ? _a : (this.isNative ? 0 : undefined);
    }
    get navigationBarHeight() {
        var _a;
        return (_a = this._driverInfo.navigationBarHeight) !== null && _a !== void 0 ? _a : (this.isNative ? 0 : undefined);
    }
    get isNative() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isNative) !== null && _b !== void 0 ? _b : false;
    }
    get isWeb() {
        return !this.isNative;
    }
    get isMobile() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isMobile) !== null && _b !== void 0 ? _b : false;
    }
    get isIOS() {
        return this.platformName === 'iOS';
    }
    get isAndroid() {
        return this.platformName === 'Android';
    }
    get isIE() {
        return /(internet explorer|ie)/i.test(this.browserName);
    }
    get isEdgeLegacy() {
        return /edge/i.test(this.browserName) && Number(this.browserVersion) <= 44;
    }
    updateCurrentContext(context) {
        this._currentContext = context;
    }
    async init() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        this._driverInfo = await ((_b = (_a = this._spec).getDriverInfo) === null || _b === void 0 ? void 0 : _b.call(_a, this.target));
        if (this.isWeb) {
            const userAgent = (_d = (_c = this._driverInfo) === null || _c === void 0 ? void 0 : _c.userAgent) !== null && _d !== void 0 ? _d : (await this.execute(snippets.getUserAgent));
            const pixelRatio = (_f = (_e = this._driverInfo) === null || _e === void 0 ? void 0 : _e.pixelRatio) !== null && _f !== void 0 ? _f : (await this.execute(snippets.getPixelRatio));
            const userAgentInfo = userAgent ? user_agent_1.parseUserAgent(userAgent) : {};
            this._driverInfo = Object.assign(Object.assign({}, this._driverInfo), { isMobile: (_h = (_g = this._driverInfo) === null || _g === void 0 ? void 0 : _g.isMobile) !== null && _h !== void 0 ? _h : ['iOS', 'Android'].includes(userAgentInfo.platformName), platformName: ((_j = this._driverInfo) === null || _j === void 0 ? void 0 : _j.isMobile)
                    ? (_l = (_k = this._driverInfo) === null || _k === void 0 ? void 0 : _k.platformName) !== null && _l !== void 0 ? _l : userAgentInfo.platformName
                    : (_m = userAgentInfo.platformName) !== null && _m !== void 0 ? _m : (_o = this._driverInfo) === null || _o === void 0 ? void 0 : _o.platformName, platformVersion: ((_p = this._driverInfo) === null || _p === void 0 ? void 0 : _p.isMobile)
                    ? (_r = (_q = this._driverInfo) === null || _q === void 0 ? void 0 : _q.platformVersion) !== null && _r !== void 0 ? _r : userAgentInfo.platformVersion
                    : (_s = userAgentInfo.platformVersion) !== null && _s !== void 0 ? _s : (_t = this._driverInfo) === null || _t === void 0 ? void 0 : _t.platformVersion, browserName: (_u = userAgentInfo.browserName) !== null && _u !== void 0 ? _u : (_v = this._driverInfo) === null || _v === void 0 ? void 0 : _v.browserName, browserVersion: (_w = userAgentInfo.browserVersion) !== null && _w !== void 0 ? _w : (_x = this._driverInfo) === null || _x === void 0 ? void 0 : _x.browserVersion, userAgent,
                pixelRatio });
        }
        else {
            if (this.isAndroid) {
                this._driverInfo.statusBarHeight = this._driverInfo.statusBarHeight / this.pixelRatio;
                this._driverInfo.navigationBarHeight = this._driverInfo.navigationBarHeight / this.pixelRatio;
            }
            if (!this._driverInfo.viewportSize) {
                const displaySize = await this.getDisplaySize();
                this._driverInfo.viewportSize = {
                    width: displaySize.width,
                    height: displaySize.height - this._driverInfo.statusBarHeight,
                };
            }
        }
        this._logger.log('Driver initialized', this._driverInfo);
        return this;
    }
    async refreshContexts() {
        if (this.isNative)
            return this.currentContext;
        const spec = this._spec;
        const utils = this._utils;
        let currentContext = this.currentContext.target;
        let contextInfo = await getContextInfo(currentContext);
        const path = [];
        if (spec.parentContext) {
            while (!contextInfo.isRoot) {
                currentContext = await spec.parentContext(currentContext);
                const contextReference = await findContextReference(currentContext, contextInfo);
                if (!contextReference)
                    throw new Error('Unable to find out the chain of frames');
                path.unshift(contextReference);
                contextInfo = await getContextInfo(currentContext);
            }
        }
        else {
            currentContext = await spec.mainContext(currentContext);
            path.push(...(await findContextPath(currentContext, contextInfo)));
        }
        this._currentContext = this._mainContext;
        return this.switchToChildContext(...path);
        async function getContextInfo(context) {
            const [documentElement, selector, isRoot, isCORS] = await spec.executeScript(context, snippets.getContextInfo);
            return { documentElement, selector, isRoot, isCORS };
        }
        async function getChildContextsInfo(context) {
            const framesInfo = await spec.executeScript(context, snippets.getChildFramesInfo);
            return framesInfo.map(([contextElement, isCORS]) => ({ contextElement, isCORS }));
        }
        async function isEqualElements(context, element1, element2) {
            return spec.executeScript(context, snippets.isEqualElements, [element1, element2]).catch(() => false);
        }
        async function findContextReference(context, contextInfo) {
            if (contextInfo.selector) {
                const contextElement = await spec.findElement(context, utils.transformSelector({ type: 'xpath', selector: contextInfo.selector }));
                if (contextElement)
                    return contextElement;
            }
            for (const childContextInfo of await getChildContextsInfo(context)) {
                if (childContextInfo.isCORS !== contextInfo.isCORS)
                    continue;
                const childContext = await spec.childContext(context, childContextInfo.contextElement);
                const contentDocument = await spec.findElement(childContext, utils.transformSelector('html'));
                const isWantedContext = await isEqualElements(childContext, contentDocument, contextInfo.documentElement);
                await spec.parentContext(childContext);
                if (isWantedContext)
                    return childContextInfo.contextElement;
            }
        }
        async function findContextPath(context, contextInfo, contextPath = []) {
            const contentDocument = await spec.findElement(context, utils.transformSelector('html'));
            if (await isEqualElements(context, contentDocument, contextInfo.documentElement)) {
                return contextPath;
            }
            for (const childContextInfo of await getChildContextsInfo(context)) {
                const childContext = await spec.childContext(context, childContextInfo.contextElement);
                const possibleContextPath = [...contextPath, childContextInfo.contextElement];
                const wantedContextPath = await findContextPath(childContext, contextInfo, possibleContextPath);
                await spec.mainContext(context);
                if (wantedContextPath)
                    return wantedContextPath;
                for (const contextElement of contextPath) {
                    await spec.childContext(context, contextElement);
                }
            }
        }
    }
    async switchTo(context) {
        if (await this.currentContext.equals(context)) {
            this._currentContext = context;
            return;
        }
        const currentPath = this.currentContext.path;
        const requiredPath = context.path;
        let diffIndex = -1;
        for (const [index, context] of requiredPath.entries()) {
            if (currentPath[index] && !(await currentPath[index].equals(context))) {
                diffIndex = index;
                break;
            }
        }
        if (diffIndex === 0) {
            throw new Error('Cannot switch to the context, because it has different main context');
        }
        else if (diffIndex === -1) {
            if (currentPath.length === requiredPath.length) {
                // required and current paths are the same
                return this.currentContext;
            }
            else if (requiredPath.length > currentPath.length) {
                // current path is a sub-path of required path
                return this.switchToChildContext(...requiredPath.slice(currentPath.length));
            }
            else if (currentPath.length - requiredPath.length <= requiredPath.length) {
                // required path is a sub-path of current path
                return this.switchToParentContext(currentPath.length - requiredPath.length);
            }
            else {
                // required path is a sub-path of current path
                await this.switchToMainContext();
                return this.switchToChildContext(...requiredPath);
            }
        }
        else if (currentPath.length - diffIndex <= diffIndex) {
            // required path is different from current or they are partially intersected
            // chose an optimal way to traverse from current context to target context
            await this.switchToParentContext(currentPath.length - diffIndex);
            return this.switchToChildContext(...requiredPath.slice(diffIndex));
        }
        else {
            await this.switchToMainContext();
            return this.switchToChildContext(...requiredPath);
        }
    }
    async switchToMainContext() {
        if (this.isNative)
            throw new Error('Contexts are supported only for web drivers');
        this._logger.log('Switching to the main context');
        await this._spec.mainContext(this.currentContext.target);
        return (this._currentContext = this._mainContext);
    }
    async switchToParentContext(elevation = 1) {
        if (this.isNative)
            throw new Error('Contexts are supported only for web drivers');
        this._logger.log('Switching to a parent context with elevation:', elevation);
        if (this.currentContext.path.length <= elevation) {
            return this.switchToMainContext();
        }
        try {
            while (elevation > 0) {
                await this._spec.parentContext(this.currentContext.target);
                this._currentContext = this._currentContext.parent;
                elevation -= 1;
            }
        }
        catch (err) {
            this._logger.warn('Unable to switch to a parent context due to error', err);
            this._logger.log('Applying workaround to switch to the parent frame');
            const path = this.currentContext.path.slice(1, -elevation);
            await this.switchToMainContext();
            await this.switchToChildContext(...path);
            elevation = 0;
        }
        return this.currentContext;
    }
    async switchToChildContext(...references) {
        if (this.isNative)
            throw new Error('Contexts are supported only for web drivers');
        this._logger.log('Switching to a child context with depth:', references.length);
        for (const reference of references) {
            if (reference === this.mainContext)
                continue;
            const context = await this.currentContext.context(reference);
            await context.focus();
        }
        return this.currentContext;
    }
    async normalizeRegion(region) {
        if (this.isWeb || !utils.types.has(this._driverInfo, ['viewportSize', 'statusBarHeight']))
            return region;
        const scaledRegion = this.isAndroid ? utils.geometry.scale(region, 1 / this.pixelRatio) : region;
        return utils.geometry.offsetNegative(scaledRegion, { x: 0, y: this.statusBarHeight });
    }
    async getRegionInViewport(context, region) {
        await context.focus();
        return context.getRegionInViewport(region);
    }
    async element(selector) {
        return this.currentContext.element(selector);
    }
    async elements(selector) {
        return this.currentContext.elements(selector);
    }
    async execute(script, arg) {
        return this.currentContext.execute(script, arg);
    }
    async takeScreenshot() {
        const data = await this._spec.takeScreenshot(this.target);
        return utils.types.isString(data) ? data.replace(/[\r\n]+/g, '') : data;
    }
    async getViewportSize() {
        var _a;
        let size;
        if (this.isNative) {
            this._logger.log('Extracting viewport size from native driver');
            if ((_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.viewportSize) {
                size = this._driverInfo.viewportSize;
            }
            else {
                size = await this.getDisplaySize();
                if (size.height > size.width) {
                    const orientation = await this.getOrientation();
                    if (orientation === 'landscape') {
                        size = { width: size.height, height: size.width };
                    }
                }
            }
            size = utils.geometry.round(size);
        }
        else if (this._spec.getViewportSize) {
            this._logger.log('Extracting viewport size from web driver using spec method');
            size = await this._spec.getViewportSize(this.target);
        }
        else {
            this._logger.log('Extracting viewport size from web driver using js snippet');
            size = await this.mainContext.execute(snippets.getViewportSize);
        }
        this._logger.log('Extracted viewport size', size);
        return size;
    }
    async setViewportSize(size) {
        if (this.isMobile)
            return;
        if (this._spec.setViewportSize) {
            this._logger.log('Setting viewport size to', size, 'using spec method');
            await this._spec.setViewportSize(this.target, size);
            return;
        }
        this._logger.log('Setting viewport size to', size, 'using workaround');
        const requiredViewportSize = size;
        let currentViewportSize = await this.getViewportSize();
        if (utils.geometry.equals(currentViewportSize, requiredViewportSize))
            return;
        let currentWindowSize = await this._spec.getWindowSize(this.target);
        this._logger.log('Extracted window size', currentWindowSize);
        let attempt = 0;
        while (attempt++ < 3) {
            const requiredWindowSize = {
                width: currentWindowSize.width + (requiredViewportSize.width - currentViewportSize.width),
                height: currentWindowSize.height + (requiredViewportSize.height - currentViewportSize.height),
            };
            this._logger.log(`Attempt #${attempt} to set viewport size by setting window size to`, requiredWindowSize);
            await this._spec.setWindowSize(this.target, requiredWindowSize);
            await utils.general.sleep(3000);
            currentWindowSize = requiredWindowSize;
            currentViewportSize = await this.getViewportSize();
            if (utils.geometry.equals(currentViewportSize, requiredViewportSize))
                return;
            this._logger.log(`Attempt #${attempt} to set viewport size failed. Current viewport:`, currentViewportSize);
        }
        throw new Error('Failed to set viewport size!');
    }
    async getDisplaySize() {
        if (this.isWeb)
            return;
        const size = await this._spec.getWindowSize(this.target);
        return this.isAndroid ? utils.geometry.scale(size, 1 / this.pixelRatio) : size;
    }
    async getOrientation() {
        if (this.isWeb)
            return;
        const orientation = this._spec.getOrientation(this.target);
        this._logger.log('Extracted device orientation:', orientation);
        return orientation;
    }
    async getTitle() {
        if (this.isNative)
            return null;
        const title = await this._spec.getTitle(this.target);
        this._logger.log('Extracted title:', title);
        return title;
    }
    async getUrl() {
        if (this.isNative)
            return null;
        const url = this._spec.getUrl(this.target);
        this._logger.log('Extracted url:', url);
        return url;
    }
    async visit(url) {
        await this._spec.visit(this.target, url);
    }
}
exports.Driver = Driver;
